{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bemvindo ao PetalFlow","text":""},{"location":"#estrutura-do-projeto","title":"Estrutura do projeto","text":"<pre><code>petalsync/\n    logs/\n    config/\n    app.py\n    service.py  # Scritp execution the aplication\nDockerfile\ndocker-compose.yml\nproject.toml\nsupervisor.conf\nREADME.md\n</code></pre> <p>Bem-vindo ao guia de documenta\u00e7\u00e3o abrangente do PetalSync, uma poderosa ferramenta de automatiza\u00e7\u00e3o de scripts Python e SQL. Desenvolvido utilizando um conjunto de tecnologias avan\u00e7adas, incluindo Python, Docker, FastAPI e MongoDB, o PetalSync n\u00e3o \u00e9 apenas uma solu\u00e7\u00e3o robusta, mas tamb\u00e9m parte integrante do projeto petalFlow.</p> <p>Projetado para atender \u00e0s complexidades e demandas da engenharia de dados, da automa\u00e7\u00e3o de processos rob\u00f3ticos (RPA) e da extra\u00e7\u00e3o, transforma\u00e7\u00e3o e carga (ETL), o PetalSync destaca-se como uma ferramenta vers\u00e1til e essencial. Sua funcionalidade central concentra-se na automa\u00e7\u00e3o do fluxo de ingest\u00e3o de dados, proporcionando efici\u00eancia e confiabilidade em cada etapa do processo.</p> <p>Neste guia, exploraremos detalhadamente as funcionalidades, configura\u00e7\u00f5es e melhores pr\u00e1ticas do PetalSync, fornecendo uma vis\u00e3o abrangente para facilitar a implementa\u00e7\u00e3o e utiliza\u00e7\u00e3o eficaz dessa ferramenta inovadora. Prepare-se para desbravar o potencial do PetalSync e elevar suas capacidades de automatiza\u00e7\u00e3o a um novo patamar.</p>"},{"location":"#comando-para-executar-localmente","title":"Comando para Executar Localmente","text":"<ul> <li><code>sudo docker-compose up -d</code> - Construir o container com base no arquivo docker-compose.yml.</li> </ul>"},{"location":"#proposta-do-projeto","title":"Proposta do Projeto","text":"<p>Para obter informa\u00e7\u00f5es detalhadas sobre o Convutell e como us\u00e1-lo, consulte a documenta\u00e7\u00e3o completa em mkdocs.org.</p>"},{"location":"#torne-se-um-contribuidor","title":"Torne-se um Contribuidor","text":"<p>Junte-se a n\u00f3s! Torne-se parte ativa da comunidade PetalSync e contribua para o seu desenvolvimento.</p>"},{"location":"instalation/","title":"Instala\u00e7\u00e3o","text":"<p>A instala\u00e7\u00e3o do PetalSync \u00e9 bastante simples e pode ser realizada em servidores Linux e Windows atrav\u00e9s do Docker.</p>"},{"location":"instalation/#configurando-o-projeto-localmente","title":"Configurando o Projeto Localmente","text":"<p>Para executar o projeto, siga os passos abaixo:</p> <ol> <li>Clone o reposit\u00f3rio do projeto no Github.</li> <li> <p>Instale as depend\u00eancias utilizando o gerenciador de pacotes <code>Poetry</code> com o comando:</p> <p><code>poetry install</code></p> </li> <li> <p>A API de integra\u00e7\u00e3o \u00e9 constru\u00edda sobre o FastAPI 0.95.1 e requer o Python na vers\u00e3o superior a 3.10. Qualquer adapta\u00e7\u00e3o necess\u00e1ria pode ser feita em vers\u00f5es subsequentes.</p> </li> <li>Crie um arquivo <code>.env</code> contendo a string de conex\u00e3o com o MongoDB. Veja o exemplo abaixo do local de cria\u00e7\u00e3o e do conte\u00fado do arquivo:</li> </ol> <pre><code>    petalsync/\n        api/\n        app/\n        ...\n        .env  # Conte\u00fado do arquivo contendo a string de conex\u00e3o com o banco de dados\n</code></pre> <pre><code>Exemplo do conte\u00fado do arquivo:\n\n```\nMONGODB_CONNECTION_STRING=mongodb://user:password@localhost:27017/?authMechanism=DEFAULT\nMONGODB_CONNECTION_STRING_DB=database\n```\n</code></pre> <ol> <li> <p>Execute o servidor web com o comando:</p> <pre><code>uvicorn app:app --reload\n</code></pre> </li> </ol>"},{"location":"instalation/#instalacao-local-via-docker","title":"Instala\u00e7\u00e3o Local via Docker","text":"<p>Para a instala\u00e7\u00e3o via Docker, \u00e9 necess\u00e1rio possuir o Docker instalado.</p> <p>Configure o arquivo <code>docker-compose.yml</code> para adequar as configura\u00e7\u00f5es ao seu ambiente. Esta implementa\u00e7\u00e3o do projeto para a imagem Docker est\u00e1 em desenvolvimento, portanto, avalie a viabilidade das configura\u00e7\u00f5es fornecidas.</p> <pre><code>version: '3'\n\nservices:\n  petalsync:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"8000:8000\"\n      - \"5000:5000\"\n    networks:\n      - hostnet\n    environment:\n      MONGO_HOST: host.docker.internal\nnetworks:\n  hostnet:\n    external: true\n</code></pre> <p>Optamos por utilizar o Supervisor para monitoramento e controle dos nossos processos. Tanto a API como Processo de ETL ser\u00e1 monitorados pelo Supervisor. Toda a configura\u00e7\u00e3o ser\u00e1 passada para o controle do Supervidor atrav\u00e9s do arquivo supervisord.conf.</p> <pre><code>[program:etl]\ncommand=/opt/venv/bin/python /petalsync/etl.py\ndirectory=/petalsync\nautostart=true\nautorestart=true\nstartretries=3\nredirect_stderr=true\nstdout_logfile=/petalsync/logs/etl/etl.log\nstdout_logfile_maxbytes=10MB\n</code></pre> <p>Com o projeto devidamente baixado em sua m\u00e1quina, para seguir com a cria\u00e7\u00e3o da projeton em um container docker, basta executar os comando baixo:</p> <p>Use o comando abaixo para inicar o seu container. A necesside do comando linux sudo depende da configura\u00e7lao do seu amviente local. </p> <pre><code>sudo docker-compose up -d\n</code></pre> <p>As aplica\u00e7\u00e3o executa por padr\u00e3o na porta 8000. Voc\u00ea pode conferir em seu navegador atrav\u00e9s do <code>127.0.0.1:8000/docs</code>.</p>"},{"location":"Estrutura%20do%20projeto/Estrutura%20do%20projeto/","title":"Estrutura do projeto","text":"<p>O projeto consiste em tr\u00eas aplica\u00e7\u00f5es que operam em conjunto, embora inicialmente se apresentem como entidades separadas. A API desempenha o papel de ferramenta respons\u00e1vel pelo controle, gerenciamento e persist\u00eancia dos dados. Associado a ela est\u00e1 o servidor, respons\u00e1vel por executar as a\u00e7\u00f5es que s\u00e3o obtidas por meio da API e armazenadas em um banco de dados. Neste projeto, optamos por utilizar o MongoDB devido \u00e0 necessidade de lidar com grandes volumes de dados, como logs, scripts de execu\u00e7\u00e3o em Python e SQL. Estamos considerando a inclus\u00e3o de outra linguagem de captura em breve.</p>"},{"location":"Estrutura%20do%20projeto/Estrutura%20do%20projeto/#_1","title":"Estrutura do projeto","text":"<pre><code>petalsync/\n    api/\n    logs/\n    config/\n    app.py\n    service.py  # Application execution configuration file.\nDockerfile\ndocker-compose.yml\nproject.toml\nsupervisor.conf\nREADME.md\n</code></pre> <p>Por fim, temos a aplica\u00e7\u00e3o gr\u00e1fica, que contribui para uma experi\u00eancia mais amig\u00e1vel do Petalsync. Essa interface est\u00e1 sendo desenvolvida em React e, embora atualmente n\u00e3o fa\u00e7a parte do pacote Petalsync, os usu\u00e1rios t\u00eam a op\u00e7\u00e3o de baix\u00e1-la e adicion\u00e1-la \u00e0 mesma \u00e1rvore de diret\u00f3rios, conforme exemplificado acima.</p> <p>Aqui est\u00e1 uma reda\u00e7\u00e3o mais detalhada dos t\u00f3picos com base nas informa\u00e7\u00f5es fornecidas:</p>"},{"location":"Estrutura%20do%20projeto/Estrutura%20do%20projeto/#api","title":"API","text":"<p>A API \u00e9 constru\u00edda em FastAPI e utiliza o MongoDB para persist\u00eancia de dados. Ela possui documenta\u00e7\u00e3o em Swagger, que abrange todas as rotas dispon\u00edveis e suas descri\u00e7\u00f5es. Todos os aspectos gerenciais do projeto s\u00e3o persistidos em um banco de dados NoSQL, especificamente MongoDB. No entanto, a inst\u00e2ncia do MongoDB n\u00e3o \u00e9 fornecida com o projeto e \u00e9 necess\u00e1rio que o usu\u00e1rio fa\u00e7a a instala\u00e7\u00e3o e configura\u00e7\u00e3o separadamente.</p>"},{"location":"Estrutura%20do%20projeto/Estrutura%20do%20projeto/#logs","title":"Logs","text":"<p>O sistema atualmente persiste os registros em arquivos de log. Esses logs armazenam informa\u00e7\u00f5es detalhadas sobre as execu\u00e7\u00f5es da API, bem como do servi\u00e7o de sincroniza\u00e7\u00e3o. Eles fornecem insights valiosos sobre o funcionamento do sistema, ajudando na depura\u00e7\u00e3o de problemas e no monitoramento do desempenho geral.</p>"},{"location":"Estrutura%20do%20projeto/Estrutura%20do%20projeto/#_2","title":"Estrutura do projeto","text":"<pre><code>petalsync/\n    logs/\n        api/\n            api.log\n        app/\n            app.log\n        service/\n            servide.log\n</code></pre>"},{"location":"Estrutura%20do%20projeto/Estrutura%20do%20projeto/#servico","title":"Servi\u00e7o","text":"<p>Este servi\u00e7o \u00e9 respons\u00e1vel por permanecer em standby, aguardando agendamentos de execu\u00e7\u00e3o dos projetos desenvolvidos e gerenciados atrav\u00e9s da API. Desenvolvido em Python, ele \u00e9 essencialmente monitorado, assim como outros recursos, atrav\u00e9s da visualiza\u00e7\u00e3o dos arquivos de log da aplica\u00e7\u00e3o.</p>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/","title":"API","text":"<p>A API \u00e9 utilizada para realizar o gerenciamento da aplica\u00e7\u00e3o e \u00e9 consumida pela aplica\u00e7\u00e3o front-end para facilitar a utiliza\u00e7\u00e3o da ferramenta.</p> <p>Utilizamos o framework FastAPI para a constru\u00e7\u00e3o da API e o MongoDB como banco de dados para persist\u00eancia dos dados.</p> <p></p>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/#projetos","title":"Projetos","text":"<p>Todos os scripts s\u00e3o realizados dentro de um projeto. O projeto \u00e9 respons\u00e1vel por gerenciar uma ou v\u00e1rias consultas constru\u00eddas em Python ou SQL. O projeto pode possuir conex\u00f5es ou n\u00e3o, dependendo do tipo de projeto. Caso seja um script, ele n\u00e3o verificar\u00e1 conex\u00e3o.</p> <p>Para executar os projetos, eles precisam estar ativos, o que \u00e9 indicado pelo campo fl_actived na documenta\u00e7\u00e3o.</p> <p>URL: /GetAllProjects               M\u00e9todo: GET                Par\u00e2metros: Nenhum     Resposta de Sucesso: Lista de objetos ProjectModel representando os projetos cadastrados.</p> <p>Exemplo de requisi\u00e7\u00e3o:</p> <pre><code>[\n  {\n    \"id_project\": 1,\n    \"name_project\": \"Projeto 1\",\n    \"dt_last_run\": \"2023-06-15T10:30:00\",\n    \"fl_active\": true,\n    \"connection_origin1\": \"origem1\",\n    \"connection_origin2\": \"origem2\"\n  }\n]\n</code></pre>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/#query-queries","title":"Query (Queries)","text":"<p>A rota de Consultas (Queries) permite gerenciar opera\u00e7\u00f5es espec\u00edficas realizadas dentro de um projeto. Essa rota oferece endpoints para criar, recuperar, atualizar e excluir consultas.</p> <p>Criar Consulta Endpoint para criar uma nova consulta.</p> <pre><code>URL: /CreateQueries                 \nM\u00e9todo: POST                    \nPar\u00e2metros: Nenhum              \nCorpo da Requisi\u00e7\u00e3o: Objeto QuerySaveModel   representando os dados da consulta a ser criada.                                   \nResposta de Sucesso: Retorna o objeto QuerySaveModel representando a consulta criada.  \n</code></pre>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/#obter-consulta-por-id","title":"Obter Consulta por ID","text":"<p>Recupera uma consulta com base em um ID espec\u00edfico.</p> <pre><code>URL: /GetQueriesId/{id_query}               \nM\u00e9todo: GET                 \nPar\u00e2metros: id_query - ID da consulta a ser recuperada.                                 \nResposta de Sucesso: Retorna o objeto QueryModel representando a consulta encontrada.   \n</code></pre>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/#obter-consultas-por-id-do-projeto","title":"Obter Consultas por ID do Projeto","text":"<p>Recupera todas as consultas associadas a um projeto espec\u00edfico.</p> <pre><code>URL: /GetqueriesIdprojects/{id_project}                 \nM\u00e9todo: GET                     \nPar\u00e2metros: id_project - ID do projeto para o qual as consultas devem ser recuperadas.      \nResposta de Sucesso: Retorna o objeto       QueryModel representando a consulta encontrada.\n</code></pre>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/#atualizar-consulta","title":"Atualizar Consulta","text":"<p>Atualiza uma consulta existente com base em um ID espec\u00edfico. <pre><code>URL: /UpdateQueries/{id_query}              \nM\u00e9todo: PUT                             \nPar\u00e2metros: id_query - ID da consulta a ser atualizada.                             \nCorpo da Requisi\u00e7\u00e3o: Objeto QuerySaveModel representando os dados atualizados da consulta.                                      \nResposta de Sucesso: Retorna o objeto QueryModel representando a consulta atualizada.       \n</code></pre></p>"},{"location":"Gerenciamento/Integra%C3%A7%C3%A3o/#excluir-consulta","title":"Excluir Consulta","text":"<p>Exclui uma consulta existente com base em um ID espec\u00edfico. <pre><code>URL: /DeleteQueries/{id_query}              \nM\u00e9todo: DELETE                              \nPar\u00e2metros: id_query - ID da consulta a ser exclu\u00edda.                                    \nResposta de Sucesso: Retorna um objeto contendo a mensagem \"Consulta exclu\u00edda com sucesso\".                                     \n</code></pre></p> <p>Essas rotas permitem o gerenciamento completo das consultas, incluindo cria\u00e7\u00e3o, recupera\u00e7\u00e3o, atualiza\u00e7\u00e3o e exclus\u00e3o. Voc\u00ea pode utilizar essas informa\u00e7\u00f5es para documentar a funcionalidade e os retornos dessas rotas na sua documenta\u00e7\u00e3o.</p>"},{"location":"Gerenciamento/service/","title":"Service","text":"<p>O <code>service</code> atua como o c\u00e9rebro na aplica\u00e7\u00e3o de ingest\u00e3o de dados, sendo respons\u00e1vel por transportar informa\u00e7\u00f5es de diferentes fontes para diversos destinos. Abaixo, est\u00e3o listadas as principais classes em desenvolvimento e suas funcionalidades.</p>"},{"location":"Gerenciamento/service/#classe-conexaobancodados","title":"Classe <code>ConexaoBancoDados</code>:","text":"<p>Essa classe \u00e9 respons\u00e1vel pela cria\u00e7\u00e3o e gerenciamento de conex\u00f5es com o banco de dados. Ela possui dois principais m\u00e9todos:</p> <ul> <li> <p><code>__init__(self, ds_conexao)</code>: O construtor da classe que inicializa uma inst\u00e2ncia de <code>ConexaoBancoDados</code> com a string de conex\u00e3o <code>ds_conexao</code>.</p> </li> <li> <p><code>conectar(self)</code>: Este m\u00e9todo conecta ao banco de dados com base na string de conex\u00e3o fornecida durante a inicializa\u00e7\u00e3o da inst\u00e2ncia. Ele determina o tipo de banco de dados (MySQL, PostgreSQL ou SQLite) e cria um objeto <code>engine</code> usando SQLAlchemy para estabelecer a conex\u00e3o.</p> </li> <li> <p><code>executar_query(self, query)</code>: Este m\u00e9todo executa uma consulta SQL fornecida como par\u00e2metro utilizando a conex\u00e3o estabelecida anteriormente. Ele retorna os resultados da consulta.</p> </li> </ul> Python <pre><code>class ConexaoBancoDados:\ndef __init__(self, ds_conexao):\n    self.ds_conexao = ds_conexao\n    self.engine = None\n\ndef conectar(self):\n    if self.ds_conexao.startswith('mysql'):\n        self.engine = create_engine(self.ds_conexao)\n    elif self.ds_conexao.startswith('postgresql'):\n        self.ds_conexao = self.ds_conexao.replace(\"?charset=utf8\", \"\")\n        self.engine = create_engine(self.ds_conexao)\n    elif self.ds_conexao.startswith('sqlite'):\n        self.engine = create_engine(self.ds_conexao)\n    else:\n        raise ValueError(\"Tipo de conex\u00e3o n\u00e3o suportado\")\n\ndef executar_query(self, query):\n    with self.engine.connect() as connection:\n        stmt = text(query)\n        result = connection.execute(stmt)\n        return result.fetchall()\n</code></pre>"},{"location":"Gerenciamento/service/#classe-projectupdater","title":"Classe <code>ProjectUpdater</code>:","text":"<p>Esta classe possui um \u00fanico m\u00e9todo est\u00e1tico chamado <code>update_last_run</code>, que \u00e9 respons\u00e1vel por atualizar o registro de \u00faltima execu\u00e7\u00e3o de um projeto no banco de dados. </p> Python <pre><code>class ProjectUpdater:\n@staticmethod\ndef update_last_run(id_project):\n    project = Project.objects(id_project=id_project).first()\n    if project:\n        project.dt_last_run = datetime.now()\n        project.save()\n</code></pre>"},{"location":"Gerenciamento/service/#classe-logger","title":"Classe <code>Logger</code>:","text":"<p>Esta classe \u00e9 respons\u00e1vel por registrar entradas de log no banco de dados. Ela possui um \u00fanico m\u00e9todo chamado <code>log_entry</code>, que recebe como par\u00e2metros o ID do projeto, a mensagem de log e um indicador booleano que indica se ocorreu um erro durante a execu\u00e7\u00e3o. O m\u00e9todo insere um novo registro de log no banco de dados com as informa\u00e7\u00f5es fornecidas.</p> Python <pre><code>class Logger:\ndef log_entry(self, project_id, log_message, error=False):\n    log = Log(\n        id_project=project_id,\n        dt_execution=datetime.now(),\n        ds_log=log_message,\n        fl_error=int(error)\n    )\n    log.save()\n</code></pre>"},{"location":"Gerenciamento/service/#classe-scritpexecpy","title":"Classe <code>ScritpExecPy</code>:","text":"<p>Esta classe \u00e9 respons\u00e1vel pela execu\u00e7\u00e3o de scripts Python din\u00e2micos. Ela possui dois principais m\u00e9todos:</p> <ul> <li> <p><code>__init__(self, script)</code>: O construtor da classe que inicializa uma inst\u00e2ncia de <code>ScritpExecPy</code> com um script Python como entrada.</p> </li> <li> <p><code>execute_script(self)</code>: Este m\u00e9todo executa o script Python fornecido durante a inicializa\u00e7\u00e3o da inst\u00e2ncia. Ele captura a sa\u00edda do script e a retorna como resultado da execu\u00e7\u00e3o.</p> </li> </ul>"},{"location":"Gerenciamento/service/#classe-connection","title":"Classe <code>Connection</code>:","text":"<p>Esta classe \u00e9 respons\u00e1vel por obter informa\u00e7\u00f5es de conex\u00e3o com o banco de dados a partir do banco de dados. Ela possui um \u00fanico m\u00e9todo chamado <code>get_connection</code>, que recebe o ID do projeto como par\u00e2metro e retorna as informa\u00e7\u00f5es de conex\u00e3o associadas a esse projeto.</p>"},{"location":"Gerenciamento/service/#classe-datamigration","title":"Classe <code>DataMigration</code>:","text":"<p>Esta classe \u00e9 respons\u00e1vel pelo processo de migra\u00e7\u00e3o de dados entre diferentes fontes de dados. Ela possui dois principais m\u00e9todos:</p> <ul> <li> <p><code>__init__(self)</code>: O construtor da classe que inicializa uma inst\u00e2ncia de <code>DataMigration</code>.</p> </li> <li> <p><code>migrate_data(self)</code>: Este m\u00e9todo \u00e9 respons\u00e1vel por executar o processo de migra\u00e7\u00e3o de dados. Ele recupera informa\u00e7\u00f5es de conex\u00e3o, executa consultas de origem e destino e registra os resultados no banco de dados.</p> </li> <li> <p><code>run(self)</code>: Este m\u00e9todo inicia o processo de migra\u00e7\u00e3o de dados em um loop infinito, garantindo que o processo seja executado periodicamente.</p> </li> </ul> <p>Essas s\u00e3o as principais classes e suas fun\u00e7\u00f5es no c\u00f3digo fornecido. Cada classe desempenha um papel importante no processo de migra\u00e7\u00e3o de dados e na execu\u00e7\u00e3o do sistema como um todo.</p>"}]}